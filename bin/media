#!/bin/bash

reset="\e[0m"
bold="\e[1m"
red="\e[31m"

function media_error {
    printf "${bold}${red}*** %s${reset}\n" "$*"
    exit 1
}

function config_key {
    local -r filename="$1"
    local -r key="$2"
    local -r section="${3:-____}"

    awk -F= "
            NR==1 { p=1 }
            /^\[/ { p=0 }
            /^\[${section}\]/ { p=1 }
            p==1 && /^ *${key} *=/ { print \$2 }
        " "$filename" \
            | sed -e 's/^ *//' \
            | tail -1
}

function show_configuration {
    echo "convert_dir   = $CONVERT_DIR"
    echo "ignore_itunes = $IGNORE_ITUNES"
    echo "trash_dir     = $TRASH_DIR"
    echo "tv_base       = $TV_BASE"
}

function media_lookup_atom {
    local -r file="$1"
    local -r atom="$2"

    # the perl invocation removes a unicode byte order mark character, which
    # is probably useful, but makes it really hard to grep things consistently
    AtomicParsley "$file" -t                \
        | perl -ne 's/^[^A]+//m; print;'    \
        | grep "Atom .${atom}."             \
        | cut -c23-
}

function lookup_tv_id {
    config_key "$MEDIA_CONFIG" "$1" 'tv-ids'
}

function extract_track_metadata {
    local -r track="$1"

    awk "/^\+ title ${track}:/{flag=1;next} /^\+ title /{flag=0} flag"
}

function extract_audio_tracks {
    awk "/^  \+ audio tracks:/{flag=1;next} /^  \+/{flag=0} flag"
}

function extract_chapters {
    awk "/^  \+ chapters:/{flag=1;next} /^  \+/{flag=0} flag"
}

function summary_line {
    if [ "$1" = '--summary' ]; then
        echo "$2"
        exit
    fi
}

function list_available_commands {
    for command in $( compgen -c | grep '^media-' ); do
        printf '%16s  ' "$( echo "$command" | cut -c7- )"
        $command --summary
    done
}

function run_command {
    local -r command="media-$1"
    shift

    $command "$@"
}

# default configuration
CONVERT_DIR=/tmp
IGNORE_ITUNES=
TRASH_DIR=
TV_BASE=/files/tv

# override config with file
if [ -n "$MEDIA_CONFIG" ]; then
    convert="$( config_key "$MEDIA_CONFIG" convert_dir )"
    [ -n "$convert" ] && CONVERT_DIR="${convert}"
    ignore="$( config_key "$MEDIA_CONFIG" ignore_itunes )"
    [ -n "$ignore" ] && IGNORE_ITUNES="${ignore}"
    trash="$( config_key "$MEDIA_CONFIG" trash_dir )"
    [ -n "$trash" ] && TRASH_DIR="${trash}"
    tv="$( config_key "$MEDIA_CONFIG" tv_base )"
    [ -n "$tv" ] && TV_BASE="${tv}"
fi

# override with env, which takes precedence over file
CONVERT_DIR="${MEDIA_CONVERT_DIR:=$CONVERT_DIR}"
IGNORE_ITUNES="${MEDIA_IGNORE_ITUNES:=$IGNORE_ITUNES}"
TRASH_DIR="${MEDIA_TRASH_DIR:=$TRASH_DIR}"
TV_BASE="${MEDIA_TV_BASE:=$TV_BASE}"


if [ "$0" = "${BASH_SOURCE[0]}" ]; then
    # being run as a command, not sourced by another script
    case "$1" in
        ''|-h|--help)
            list_available_commands
            ;;

        show-config)
            show_configuration
            ;;

        *)  run_command "$@"
            ;;
    esac
fi
